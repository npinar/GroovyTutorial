package com.myjavasolutions.groovy.tutorial;

import static org.junit.Assert.*;

class GroovyDemoTest  extends GroovyTestCase {
	
	GroovyDemo groovyDemo;
	
	public GroovyDemoTest() {
		groovyDemo = new GroovyDemo();
	}
	
	void test_automatic_getter_setter() {
		
		String expected = "nevzat";
		
		//calling groovy's automatic getter and setter methods.
		groovyDemo.setFirstName(expected);
		assert groovyDemo.getFirstName() == expected 
	}
	
	void test_auto_generated_constructor() {
		
		//the following constructor created by groovy automatically
		GroovyDemo groovyDemo = new GroovyDemo(firstName: "nevzat");
		assert groovyDemo.getFirstName() == "nevzat"
		
		//here is another constructor that is generated by groovy
		GroovyDemo demo = new GroovyDemo(firstName: "nevzat", companyId: 12345);
		//the following line calls the setter method of companyId
		assert demo.getCompanyId() == 12345
	}
	
	void test_equality_and_reference() {
		
		GroovyDemo groovyDemo = new GroovyDemo(firstName: "nevzat");
		GroovyDemo demo = new GroovyDemo(firstName: "nevzat");
		
		//checking the values of the objects. == will check for equality
		assert demo.getFirstName() == groovyDemo.getFirstName()
		
		//checking for reference
		assertFalse groovyDemo.is(demo)
		
		groovyDemo = demo;
		//checking for reference
		assertTrue groovyDemo.is(demo)
	}
	
	void test_optional_parameters() {
		
		BigDecimal expected = 26.0;
		BigDecimal actual = groovyDemo.getPrice("1", "someLocation");
		
		assert expected == actual
		
		BigDecimal expectedDiscountPrice = 10.0;
		actual = groovyDemo.getPrice("1", "someLocation", 15);
		
		assert expectedDiscountPrice == actual
	}
	
	void test_looping() {
		
		def someList = ["some string", "another string", 1, 2]
		
		//the following line will print everything in the list
		//by using the implicit variable it
		someList.each { println it }
		
		//here we create a variable name items and
		//assign the values of each iteration to it
		someList.each {items-> println items}
		
		System.out.println("Groovy supports Java foreach loops");
		for(String myList : someList) {
			System.out.println(myList);
		}
		
		System.out.println("Groovy supports standard Java loops");
		for(int i = 0; i < someList.size(); i++) {
			System.out.println(someList.get(i));
		}
		
		//looping with groovy range future
		//no need to define a type for i
		for(i in 0..6) {
			println ("index $i")
		}
		
		//another way of looping
		def index = 5
		for (i in 0..index-1) {
			println i
		}
		
		//another way of looping
		for (i in 0..<index) {
			println i
		}
		
		//another way of looping
		index.times {println "loop it 5 times"}
	}
	
	void test_groovy_methods() {
		
		 3.times {println "This will print 3 times" }
		 
		 //the following line shows how you can access the index
		 2.times {println "Times: $it "}
		 
		 //start from 10 and go down to 6
		 10.downto(6) {println "Downto: $it "}
		 
		 //start from 2 and go up to 5
		 2.upto(5) {println "Upto: $it "}
		 
		 //example of how to specify a range of numbers
		 (3..6).each {println "Range: $it"}
		 
		 //let's add all the numbers from 1 to 10
		 def expected = 55
		 def actual = 0;
		 
		 1.upto(10) { actual += it }
		 assert expected == actual
		 
		 String someNumber = "2";
		 assert 2 == someNumber.toInteger()
	}
	
	void test_groovy_operators() {
		
		assert 10 == 5.plus(5)
		assert 10 == 15.minus(5)
		assert 10 == 2.multiply(5)
		assert 10 == 20.div(2)
		assert 10 == 11.previous()
		assert 10 == 9.next()
		
		//safe navigation operator
		GroovyDemo groovyDemo = null
		//since groovyDemo is null, someVariable will get null instead
		//of getting null pointer exception
		def someVariable = groovyDemo?.getFirstName()
		assert null == someVariable
		
		//elvis operator: short form of java ternary operator
		//if groovyDemo object exists return it; otherwise return new instance
		groovyDemo = groovyDemo ?: new GroovyDemo()
		assertNotNull(groovyDemo)
		
	}
	
	void test_automatic_type_casting() {
		
		//the following shows how groovy casts types automaticly 
		def value = 2.0F
		println "value is: " + value + " and the type is: " + value.getClass().getName()
		
		def anotherValue = 5;
		println "anotherValue is: " + anotherValue + " and the type is: " + anotherValue.getClass().getName()
		
		anotherValue = anotherValue / value
		println "after division anotherValue is: " + anotherValue + " and the type is now: " + anotherValue.getClass().getName()
		
		//All variables in Groovy are reference variables. 
		//there are no primitive variables.
		int i = 0;
		assert  "java.lang.Integer" == i.getClass().getName()
	}
	
	void test_GStrings() {
		
		def expected = "john doe"
		
		//the following is a GString since it is declared with ""
		def lastName = "doe"
		def fullName = "john $lastName"
		
		assert expected == fullName
		
		//the following is not a GString
		def custLastName = 'doe'
		//since it is not a GString, custLastName will not be replaced
		def custFullName = 'john $custLastName'
		
		assertFalse expected == custFullName
		
		assert "org.codehaus.groovy.runtime.GStringImpl" ==  fullName.getClass().getName()
		assert "java.lang.String" == custFullName.getClass().getName()
	}
	
	void test_maps() {
		
		//creating an empty map
		Map map = [:]
		assert 0 == map.size()
		
		//adding a value and retrieving it from map
		map.put("test", 123)
		assert 123 == map.get("test")
		
		//different ways to retrieve values from map
		def anotherMap = ["test":"12", "customer":"texas", "id":123]
		assert 123 == anotherMap["id"]
		assert 123 == anotherMap.get("id")
		assert 123 == anotherMap.id
		
		//another way to add a value to map 
		anotherMap["newKey"] = "new key value"
		assert "new key value" == anotherMap.get("newKey")
	}
	
	void test_list() {
		
		//creating an empty List
		List emptyList = []
		assert 0 == emptyList.size()
		
		//create a dummy list
		List someList = [1,2,"test"]
		
		assert 2 == someList[1]
		assert "test" == someList[2]
		assert null == someList[3]
		assert 3 == someList.size()
		
	}

	void test_missing_method() {
		
		groovyDemo.someMethodThatDoesNotExist("hello", "hi")
		groovyDemo.anotherMethodWithoutParams()
	}
	
	void test_missing_properties() {
		
		groovyDemo.zipCode = 7112
		assert "this getter property does not exists" == groovyDemo.zipCode
	}
	
	void test_create_arrays() {
		
		//in groovy, we have to use [] when declaring arrays
		//instead of {}
		int[] a = [1,2,3];
		a.each {output -> println output}
	}
	
	void test_optional_return_value() {
		//since there is no return value, it will return false
		assert false == groovyDemo.returnValueOptionalWithBoolean()
		
		//will return null for Strings
		assert null == groovyDemo.returnValueOptionalString()
	}
	
	void test_closure() {
		
		//closure that returns back the passed input
		def echo = { input -> return input }
		assert "hello" == echo("hello")
		assert 3 == echo(3)
		//another way to call closure
		assert 5 == echo.call(5)
		
		//closure that returns back the passed input as String always
		def echoAsString = { input -> return "${input}" }
		assert "hello" == echoAsString("hello")
		assert "3" == echoAsString(3)
		assert "3.5" == echoAsString(3.5)
		
		//Closure that is with 1 argument since token -> is not used while constructing the closure
		def someClosure = { "this is a closure which will get executed when clos is called" }
		assert "this is a closure which will get executed when clos is called" == someClosure()
		assert "this is a closure which will get executed when clos is called" == someClosure("default argument")
		
		//Closure with two parameters
		def fullName = { firstName, lastName -> return firstName + " " + lastName }
		assert "john doe" == fullName("john", "doe")
		
		//The -> token is optional and may be omitted if the Closure definition takes less than two parameters.
		def optionalToken = { "hello $it" }
		assert "hello john"  == optionalToken("john")
		
		//If you have a Closure that takes a single argument, you may omit the parameter definition
		//and it will return whatever data type you pass
		def implicitVariableReturn = { it }
		assert "john"  == implicitVariableReturn("john")
		assert 2 == implicitVariableReturn(2)
		
		//Constructing a Closure with zero arguments by putting ->
		def closureWithZeroArguments = { -> "hello"}
		//in the following Closure call, you cannot pass a parameter
		assert "hello" == closureWithZeroArguments()
		
		//the following example shows how Closure can access other variables.
		def someVariable = 1
		def increamentByOne = { num -> num + someVariable }
		assert 3 == increamentByOne(2)
		
		//the following example shows how we can bound method call to Closure
		def myClosure = groovyDemo.someLocalMethod()
		assert "hello" == myClosure()
		
		//the following example shows how we can pass Closure to built in function
		List input = [1,2,3,4]
		def addItself = { it + it}
		
		//We will call the collect method on the input list and pass the Closure we defined in the previous line 
		//The collect method will run through each item in the list and will call the closure on the item;
		//then it will put the result in a new list
		List newList = input.collect(addItself)
		assert 2 == newList[0]
		assert 4 == newList[1]
		assert 6 == newList[2]
		assert 8 == newList[3]
		
		//in the following example collect has anonymous Closure
		List anotherList = input.collect { it + it}
		assert 2 == anotherList[0]
		assert 4 == anotherList[1]
		
		//let's use the same logic above and print the values in the map
		Map myMap = ["name" : "nev", "id" : 1, "location" : "north"]
		def printMapContent = {key, value -> println key + ":" + value}
		
		//the following line will call the Closure on the map
		myMap.each(printMapContent)
		
		//another anonymous Closure in each method
		def outputFromMap = "result: ";
		myMap.keySet().each { outputFromMap += " " + myMap[it] }
		assert "result:  nev 1 north" == outputFromMap
	}
	
	void test_method_return_type() {
		
		//Groovy does not require the return keyword. It will simply return the last expression.
		assert "test" == groovyDemo.whatIsMyReturnType("test")
	}
	
	void test_no_primitive_type() {
		
		//In groovy everything is an object
		int custId = 12
		assert java.lang.Integer == custId.class
		
		//also in groovy, you can use def and groovy will figure out the type
		def someVariable = 12
		assert java.lang.Integer == someVariable.class
		
		double amount = 12.0
		assert java.lang.Double == amount.class
		
		def name = "nev"
		assert java.lang.String == name.class
	}
	
	void test_method_param_without_type() {
		
		//Groovy does not require type for the method parameter
		assert "hello" == groovyDemo.echo("hello")
	}
	
	void test_collections() {
		
		//Groovy uses collections directly within the language
		//do not need to import a specialized class or do not need to initialize an object
		//A collection is a native member of the language itself
		
		def range = 0..4
		assert range instanceof List
		
		def favoriteFood = ["pizza", "hamburger", "cheese cake"]
		assert  favoriteFood instanceof Collection
		assert favoriteFood instanceof ArrayList
		
		//different ways to add to collection
		favoriteFood.add("salad")
		favoriteFood << "cheese"
		favoriteFood[5] = "bread"
		
		//capitalize all the strings in the collection before printing out
		favoriteFood*.toUpperCase().each { println it }
		
		//add and subtract collections from each other
		def someNumbers = [1,2,3,4,5,6,7]
		assert someNumbers + 8 == [1,2,3,4,5,6,7,8]
		assert someNumbers - [2,3,6,7] == [1,4,5]
	}
}

